"""Skill model definitions.

A Skill is the atomic unit of knowledge in the Skills-First architecture.
Each skill defines a structured set of instructions, context requirements,
validation rules, and scoring criteria that CLI/IDE agents can read and execute.
"""

from enum import Enum
from typing import Any, Dict, List, Optional

from pydantic import BaseModel, Field


class SkillRole(str, Enum):
    """Roles that a skill can be assigned to."""

    DEVELOPER = "developer"
    REVIEWER = "reviewer"
    TESTER = "tester"
    ARCHITECT = "architect"
    DEVOPS = "devops"
    ANALYST = "analyst"
    DOCUMENTER = "documenter"


class SkillSource(str, Enum):
    """Origin of a skill definition."""

    BUILTIN = "builtin"       # Shipped with the framework
    GENERATED = "generated"   # Auto-generated by SkillGenerator
    USER = "user"             # Created by user
    REMOTE = "remote"         # Pulled from remote registry


class ContextSpec(BaseModel):
    """Specification for what context a skill needs from the project.

    Used by the ContextOptimizer to gather and prioritize
    the right information before skill execution.
    """

    required_files: List[str] = Field(
        default_factory=list,
        description="Glob patterns for files the skill needs (e.g. '*.py', 'src/**/*.ts')",
    )
    required_context: List[str] = Field(
        default_factory=list,
        description="Named context items (e.g. 'project_structure', 'dependencies', 'tech_stack')",
    )
    max_tokens: int = Field(
        default=4000,
        description="Maximum token budget for this skill's context window",
    )
    priority_keywords: List[str] = Field(
        default_factory=list,
        description="Keywords to prioritize when ranking context items",
    )


class SkillStep(BaseModel):
    """A single step within a skill's execution workflow.

    Steps are sequential instructions that an agent follows.
    Each step can reference other skills as dependencies.
    """

    name: str = Field(..., description="Step identifier")
    action: str = Field(..., description="What the agent should do")
    description: str = Field(default="", description="Detailed instruction")
    expected_output: str = Field(
        default="", description="Description of expected output"
    )
    depends_on: List[str] = Field(
        default_factory=list,
        description="Step names that must complete first",
    )
    skill_ref: Optional[str] = Field(
        default=None,
        description="Reference to another skill to delegate to",
    )
    validation: Optional[str] = Field(
        default=None,
        description="Validation assertion for step output",
    )


class SkillMetadata(BaseModel):
    """Runtime metadata tracked by the registry for scoring and learning."""

    execution_count: int = Field(default=0, description="Times this skill was used")
    success_count: int = Field(default=0, description="Successful executions")
    avg_score: float = Field(default=0.0, description="Average review score (0-1)")
    last_used: Optional[str] = Field(default=None, description="ISO timestamp")
    tags_generated: List[str] = Field(
        default_factory=list,
        description="Tags auto-generated from execution history",
    )

    @property
    def success_rate(self) -> float:
        """Calculate success rate."""
        if self.execution_count == 0:
            return 0.0
        return self.success_count / self.execution_count


class Skill(BaseModel):
    """Core skill definition.

    A skill is a structured unit of knowledge that describes:
    - WHAT to do (description, steps)
    - WHO should do it (role)
    - HOW to validate it (validation_rules, score_criteria)
    - WHAT context is needed (context_requirements)

    Skills are the primary interface between the framework and CLI/IDE agents.
    Agents read skill definitions (as SKILL.md or YAML) and execute them.
    """

    name: str = Field(..., description="Unique skill identifier (kebab-case)")
    description: str = Field(..., description="Human-readable description")
    role: SkillRole = Field(..., description="Primary role for this skill")
    category: str = Field(..., description="Category (e.g. 'frontend', 'backend')")
    tags: List[str] = Field(default_factory=list, description="Searchable tags")
    prerequisites: List[str] = Field(
        default_factory=list,
        description="Skill names that must be completed first (e.g. 'skill:setup-node')",
    )
    prompt_template: str = Field(
        default="",
        description="Jinja2 template for generating the execution prompt",
    )
    workflow_steps: List[SkillStep] = Field(
        default_factory=list,
        description="Ordered sequence of execution steps",
    )
    validation_rules: List[str] = Field(
        default_factory=list,
        description="Assertions to validate skill output",
    )
    context_requirements: ContextSpec = Field(
        default_factory=ContextSpec,
        description="Context specification for this skill",
    )
    score_criteria: Dict[str, float] = Field(
        default_factory=dict,
        description="Scoring criteria with weights (e.g. {'correctness': 0.4, 'style': 0.3})",
    )
    version: str = Field(default="1.0.0", description="Skill version (semver)")
    source: SkillSource = Field(
        default=SkillSource.BUILTIN, description="Origin of this skill"
    )
    metadata: SkillMetadata = Field(
        default_factory=SkillMetadata,
        description="Runtime metadata (managed by registry)",
    )

    def to_skill_md(self) -> str:
        """Render skill as SKILL.md format for agent consumption.

        Returns:
            Markdown string in SKILL.md convention.
        """
        lines = [
            f"# Skill: {self.name}",
            "",
            f"**Role**: {self.role.value}",
            f"**Category**: {self.category}",
            f"**Tags**: {', '.join(self.tags)}",
            "",
            "## Description",
            "",
            self.description,
            "",
        ]

        if self.prerequisites:
            lines.extend([
                "## Prerequisites",
                "",
                *[f"- {p}" for p in self.prerequisites],
                "",
            ])

        if self.workflow_steps:
            lines.extend([
                "## Steps",
                "",
            ])
            for i, step in enumerate(self.workflow_steps, 1):
                lines.append(f"### Step {i}: {step.name}")
                lines.append("")
                lines.append(f"**Action**: {step.action}")
                if step.description:
                    lines.append(f"\n{step.description}")
                if step.expected_output:
                    lines.append(f"\n**Expected Output**: {step.expected_output}")
                if step.validation:
                    lines.append(f"\n**Validation**: {step.validation}")
                lines.append("")

        if self.validation_rules:
            lines.extend([
                "## Validation Rules",
                "",
                *[f"- {r}" for r in self.validation_rules],
                "",
            ])

        if self.score_criteria:
            lines.extend([
                "## Scoring Criteria",
                "",
                *[
                    f"- **{k}**: weight {v}"
                    for k, v in self.score_criteria.items()
                ],
                "",
            ])

        return "\n".join(lines)

    def to_yaml_dict(self) -> Dict[str, Any]:
        """Convert skill to a YAML-serializable dictionary.

        Returns:
            Dictionary suitable for YAML serialization.
        """
        data = self.model_dump(exclude={"metadata"})
        data["role"] = self.role.value
        data["source"] = self.source.value
        data["context_requirements"] = self.context_requirements.model_dump()
        data["workflow_steps"] = [s.model_dump() for s in self.workflow_steps]
        return data
